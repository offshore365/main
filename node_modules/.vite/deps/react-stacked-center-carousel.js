import {
  require_react_dom
} from "./chunk-G52XTN3B.js";
import {
  require_react
} from "./chunk-LXGCQ6UQ.js";
import {
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/react-stacked-center-carousel/dist/index.modern.js
var import_react2 = __toESM(require_react());

// node_modules/react-resize-detector/build/index.esm.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function isObject$3(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$3;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal || freeSelf || Function("return this")();
var _root = root$2;
var root$1 = _root;
var now$1 = function() {
  return root$1.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var root = _root;
var Symbol$2 = root.Symbol;
var _Symbol = Symbol$2;
var Symbol$1 = _Symbol;
var objectProto$1 = Object.prototype;
var hasOwnProperty = objectProto$1.hasOwnProperty;
var nativeObjectToString$1 = objectProto$1.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol2 = _Symbol;
var getRawTag = _getRawTag;
var objectToString = _objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$1;
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$1;
var baseGetTag = _baseGetTag;
var isObjectLike = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var isSymbol_1 = isSymbol$1;
var baseTrim = _baseTrim;
var isObject$2 = isObject_1;
var isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var isObject$1 = isObject_1;
var now = now_1;
var toNumber = toNumber_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax = Math.max;
var nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var debounce = debounce_1;
var isObject = isObject_1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
var patchResizeHandler = function(resizeCallback, refreshMode, refreshRate, refreshOptions) {
  switch (refreshMode) {
    case "debounce":
      return debounce_1(resizeCallback, refreshRate, refreshOptions);
    case "throttle":
      return throttle_1(resizeCallback, refreshRate, refreshOptions);
    default:
      return resizeCallback;
  }
};
var isFunction = function(fn) {
  return typeof fn === "function";
};
var isSSR = function() {
  return typeof window === "undefined";
};
var isDOMElement = function(element) {
  return element instanceof Element || element instanceof HTMLDocument;
};
var createNotifier = function(onResize, setSize, handleWidth, handleHeight) {
  return function(_a) {
    var width = _a.width, height = _a.height;
    setSize(function(prev) {
      if (prev.width === width && prev.height === height) {
        return prev;
      }
      if (prev.width === width && !handleHeight || prev.height === height && !handleWidth) {
        return prev;
      }
      if (onResize && isFunction(onResize)) {
        onResize(width, height);
      }
      return { width, height };
    });
  };
};
var ResizeDetector = (
  /** @class */
  function(_super) {
    __extends(ResizeDetector2, _super);
    function ResizeDetector2(props) {
      var _this = _super.call(this, props) || this;
      _this.cancelHandler = function() {
        if (_this.resizeHandler && _this.resizeHandler.cancel) {
          _this.resizeHandler.cancel();
          _this.resizeHandler = null;
        }
      };
      _this.attachObserver = function() {
        var _a2 = _this.props, targetRef = _a2.targetRef, observerOptions = _a2.observerOptions;
        if (isSSR()) {
          return;
        }
        if (targetRef && targetRef.current) {
          _this.targetRef.current = targetRef.current;
        }
        var element = _this.getElement();
        if (!element) {
          return;
        }
        if (_this.observableElement && _this.observableElement === element) {
          return;
        }
        _this.observableElement = element;
        _this.resizeObserver.observe(element, observerOptions);
      };
      _this.getElement = function() {
        var _a2 = _this.props, querySelector = _a2.querySelector, targetDomEl = _a2.targetDomEl;
        if (isSSR())
          return null;
        if (querySelector)
          return document.querySelector(querySelector);
        if (targetDomEl && isDOMElement(targetDomEl))
          return targetDomEl;
        if (_this.targetRef && isDOMElement(_this.targetRef.current))
          return _this.targetRef.current;
        var currentElement = (0, import_react_dom.findDOMNode)(_this);
        if (!currentElement)
          return null;
        var renderType = _this.getRenderType();
        switch (renderType) {
          case "renderProp":
            return currentElement;
          case "childFunction":
            return currentElement;
          case "child":
            return currentElement;
          case "childArray":
            return currentElement;
          default:
            return currentElement.parentElement;
        }
      };
      _this.createResizeHandler = function(entries) {
        var _a2 = _this.props, _b = _a2.handleWidth, handleWidth = _b === void 0 ? true : _b, _c = _a2.handleHeight, handleHeight = _c === void 0 ? true : _c, onResize = _a2.onResize;
        if (!handleWidth && !handleHeight)
          return;
        var notifyResize = createNotifier(onResize, _this.setState.bind(_this), handleWidth, handleHeight);
        entries.forEach(function(entry) {
          var _a3 = entry && entry.contentRect || {}, width = _a3.width, height = _a3.height;
          var shouldSetSize = !_this.skipOnMount && !isSSR();
          if (shouldSetSize) {
            notifyResize({ width, height });
          }
          _this.skipOnMount = false;
        });
      };
      _this.getRenderType = function() {
        var _a2 = _this.props, render = _a2.render, children = _a2.children;
        if (isFunction(render)) {
          return "renderProp";
        }
        if (isFunction(children)) {
          return "childFunction";
        }
        if ((0, import_react.isValidElement)(children)) {
          return "child";
        }
        if (Array.isArray(children)) {
          return "childArray";
        }
        return "parent";
      };
      var skipOnMount = props.skipOnMount, refreshMode = props.refreshMode, _a = props.refreshRate, refreshRate = _a === void 0 ? 1e3 : _a, refreshOptions = props.refreshOptions;
      _this.state = {
        width: void 0,
        height: void 0
      };
      _this.skipOnMount = skipOnMount;
      _this.targetRef = (0, import_react.createRef)();
      _this.observableElement = null;
      if (isSSR()) {
        return _this;
      }
      _this.resizeHandler = patchResizeHandler(_this.createResizeHandler, refreshMode, refreshRate, refreshOptions);
      _this.resizeObserver = new window.ResizeObserver(_this.resizeHandler);
      return _this;
    }
    ResizeDetector2.prototype.componentDidMount = function() {
      this.attachObserver();
    };
    ResizeDetector2.prototype.componentDidUpdate = function() {
      this.attachObserver();
    };
    ResizeDetector2.prototype.componentWillUnmount = function() {
      if (isSSR()) {
        return;
      }
      this.observableElement = null;
      this.resizeObserver.disconnect();
      this.cancelHandler();
    };
    ResizeDetector2.prototype.render = function() {
      var _a = this.props, render = _a.render, children = _a.children, _b = _a.nodeType, WrapperTag = _b === void 0 ? "div" : _b;
      var _c = this.state, width = _c.width, height = _c.height;
      var childProps = { width, height, targetRef: this.targetRef };
      var renderType = this.getRenderType();
      var typedChildren;
      switch (renderType) {
        case "renderProp":
          return render && render(childProps);
        case "childFunction":
          typedChildren = children;
          return typedChildren(childProps);
        case "child":
          typedChildren = children;
          if (typedChildren.type && typeof typedChildren.type === "string") {
            childProps.targetRef;
            var nativeProps = __rest(childProps, ["targetRef"]);
            return (0, import_react.cloneElement)(typedChildren, nativeProps);
          }
          return (0, import_react.cloneElement)(typedChildren, childProps);
        case "childArray":
          typedChildren = children;
          return typedChildren.map(function(el) {
            return !!el && (0, import_react.cloneElement)(el, childProps);
          });
        default:
          return React.createElement(WrapperTag, null);
      }
    };
    return ResizeDetector2;
  }(import_react.PureComponent)
);
var useEnhancedEffect = isSSR() ? import_react.useEffect : import_react.useLayoutEffect;
function useResizeDetector(props) {
  if (props === void 0) {
    props = {};
  }
  var _a = props.skipOnMount, skipOnMount = _a === void 0 ? false : _a, refreshMode = props.refreshMode, _b = props.refreshRate, refreshRate = _b === void 0 ? 1e3 : _b, refreshOptions = props.refreshOptions, _c = props.handleWidth, handleWidth = _c === void 0 ? true : _c, _d = props.handleHeight, handleHeight = _d === void 0 ? true : _d, targetRef = props.targetRef, observerOptions = props.observerOptions, onResize = props.onResize;
  var skipResize = (0, import_react.useRef)(skipOnMount);
  var localRef = (0, import_react.useRef)(null);
  var ref = targetRef !== null && targetRef !== void 0 ? targetRef : localRef;
  var resizeHandler = (0, import_react.useRef)();
  var _e = (0, import_react.useState)({
    width: void 0,
    height: void 0
  }), size = _e[0], setSize = _e[1];
  useEnhancedEffect(function() {
    if (isSSR()) {
      return;
    }
    var notifyResize = createNotifier(onResize, setSize, handleWidth, handleHeight);
    var resizeCallback = function(entries) {
      if (!handleWidth && !handleHeight)
        return;
      entries.forEach(function(entry) {
        var _a2 = entry && entry.contentRect || {}, width = _a2.width, height = _a2.height;
        var shouldSetSize = !skipResize.current && !isSSR();
        if (shouldSetSize) {
          notifyResize({ width, height });
        }
        skipResize.current = false;
      });
    };
    resizeHandler.current = patchResizeHandler(resizeCallback, refreshMode, refreshRate, refreshOptions);
    var resizeObserver = new window.ResizeObserver(resizeHandler.current);
    if (ref.current) {
      resizeObserver.observe(ref.current, observerOptions);
    }
    return function() {
      resizeObserver.disconnect();
      var patchedResizeHandler = resizeHandler.current;
      if (patchedResizeHandler && patchedResizeHandler.cancel) {
        patchedResizeHandler.cancel();
      }
    };
  }, [refreshMode, refreshRate, refreshOptions, handleWidth, handleHeight, onResize, observerOptions, ref.current]);
  return __assign({ ref }, size);
}

// node_modules/react-stacked-center-carousel/dist/index.modern.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return {
          done: true
        };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var StackedCarousel = function(_React$PureComponent) {
  _inheritsLoose(StackedCarousel2, _React$PureComponent);
  function StackedCarousel2(props) {
    var _this;
    _this = _React$PureComponent.call(this, props) || this;
    _this.validateProps = function() {
      var _this$props = _this.props, swipeSpeed = _this$props.swipeSpeed, currentVisibleSlide = _this$props.currentVisibleSlide, maxVisibleSlide = _this$props.maxVisibleSlide, fadeDistance = _this$props.fadeDistance, customScales = _this$props.customScales, data = _this$props.data;
      if (data.length < (maxVisibleSlide + 1) / 2) {
        throw Error("you must have more than (maxVisibleSlide + 1) / 2 data item");
      }
      if (currentVisibleSlide && currentVisibleSlide % 2 !== 1 || maxVisibleSlide % 2 !== 1) {
        throw Error("currentVisibleSlide or maxVisibleSlide must be an odd number");
      }
      if (currentVisibleSlide && currentVisibleSlide > maxVisibleSlide) {
        throw Error("currentVisibleSlide must be smaller than maxVisibleSlide");
      }
      if (fadeDistance !== void 0) {
        if (fadeDistance > 1 || fadeDistance < 0) {
          throw Error("fadeDistance is a percentage value in the range of 0 - 1");
        }
      }
      if (customScales && customScales.length !== (maxVisibleSlide + 3) / 2) {
        throw Error("customScales must have lengh (maxVisibleSlide + 3) / 2");
      }
      if (swipeSpeed && (swipeSpeed > 0.99 || swipeSpeed < 0.01)) {
        throw Error("swipeSpeed must have a value between 0.01 and 0.99");
      }
    };
    _this.initializeProperties = function(constructor) {
      if (constructor === void 0) {
        constructor = false;
      }
      _this.validateProps();
      var _this$props2 = _this.props, carouselWidth = _this$props2.carouselWidth, slideWidth = _this$props2.slideWidth, currentVisibleDisplaySlide = _this$props2.currentVisibleSlide, maxVisibleSlide = _this$props2.maxVisibleSlide;
      var currentVisibleSlides = currentVisibleDisplaySlide || maxVisibleSlide;
      var visibleSlidePerSide = (currentVisibleSlides - 1) / 2;
      var slidePerSide2 = Math.max(visibleSlidePerSide + 1, 1);
      var totalRenderCount = maxVisibleSlide + 2;
      var renderedSlidePerSide2 = (maxVisibleSlide + 1) / 2;
      var _this$calculateScaleA = _this.calculateScaleAndOffsets(slidePerSide2), offsets = _this$calculateScaleA.offsets, scaledOffsets = _this$calculateScaleA.scaledOffsets, scales = _this$calculateScaleA.scales;
      var newRenderedSlides = constructor ? Array(totalRenderCount).fill(null) : _this.state.renderedSlides.filter(function(_ref) {
        var slideIndex2 = _ref.slideIndex, dataIndex = _ref.dataIndex;
        return dataIndex === -1 || Math.abs(slideIndex2) <= _this.slidePerSide;
      });
      var slideInfoMap2 = {};
      var newCenterSlideRelativeIndex = constructor ? (totalRenderCount - 1) / 2 : newRenderedSlides.findIndex(function(_ref2) {
        var slideIndex2 = _ref2.slideIndex;
        return slideIndex2 === 0;
      });
      var newCenterDataIndex = constructor ? 0 : newRenderedSlides[newCenterSlideRelativeIndex].dataIndex;
      var filledWidth = 0;
      var centerPosition2 = carouselWidth / 2 - slideWidth / 2;
      var _loop = function _loop2(absIndex2) {
        var offset = offsets[absIndex2];
        var slideScale = scales[absIndex2];
        var currentOffSet = filledWidth + offset;
        [-absIndex2, absIndex2].forEach(function(slideIndex2) {
          var relativeIndex = newCenterSlideRelativeIndex + slideIndex2;
          var position = slideIndex2 >= 0 ? currentOffSet : -currentOffSet;
          var opacity = absIndex2 === slidePerSide2 ? 0 : 1;
          var dataIndex = _this.modDataRange(newCenterDataIndex + slideIndex2);
          newRenderedSlides[relativeIndex] = {
            dataIndex,
            scale: slideScale,
            position,
            slideIndex: slideIndex2,
            opacity,
            zIndex: renderedSlidePerSide2 - Math.abs(slideIndex2),
            key: constructor ? slideIndex2 : newRenderedSlides[relativeIndex].key
          };
          slideInfoMap2[slideIndex2] = {
            position,
            scale: slideScale,
            opacity
          };
        });
        if (absIndex2 !== 0)
          filledWidth += scaledOffsets[absIndex2];
      };
      for (var absIndex = 0; absIndex <= slidePerSide2; absIndex++) {
        _loop(absIndex);
      }
      for (var i = -slidePerSide2; i <= slidePerSide2; i++) {
        slideInfoMap2[i].maxTransformDistance = {};
        slideInfoMap2[i].maxTransformScale = {};
        slideInfoMap2[i].maxTransformOpacity = {
          left: i === -slidePerSide2 + 1 || i === slidePerSide2 ? 1 : 0,
          right: i === -slidePerSide2 || i === slidePerSide2 - 1 ? 1 : 0
        };
        slideInfoMap2[i].slideIndex = i;
        if (i === -slidePerSide2) {
          slideInfoMap2[i].maxTransformDistance.left = 0;
          slideInfoMap2[i].maxTransformScale.left = 0;
        } else {
          slideInfoMap2[i].maxTransformDistance.left = slideInfoMap2[i].position - slideInfoMap2[i - 1].position;
          slideInfoMap2[i].maxTransformScale.left = Math.abs(slideInfoMap2[i].scale - slideInfoMap2[i - 1].scale);
        }
        if (i === slidePerSide2) {
          slideInfoMap2[i].maxTransformDistance.right = 0;
          slideInfoMap2[i].maxTransformScale.right = 0;
        } else {
          slideInfoMap2[i].maxTransformDistance.right = slideInfoMap2[i + 1].position - slideInfoMap2[i].position;
          slideInfoMap2[i].maxTransformScale.right = Math.abs(slideInfoMap2[i + 1].scale - slideInfoMap2[i].scale);
        }
      }
      if (maxVisibleSlide > currentVisibleSlides) {
        var maxRenderedSlidePerSide = (maxVisibleSlide + 1) / 2;
        var currentSlidePerSide = slidePerSide2;
        for (var _i = currentSlidePerSide + 1; _i <= maxRenderedSlidePerSide; _i++) {
          for (var direct = 1; direct >= 0; direct--) {
            var insertIndex = newCenterSlideRelativeIndex + (direct === 1 ? _i : -_i);
            var prevIndex = insertIndex + (direct === 1 ? -1 : 1);
            var slideIndex = direct === 1 ? _i : -_i;
            var scalePositionIndex = constructor ? prevIndex : insertIndex;
            newRenderedSlides[insertIndex] = {
              scale: newRenderedSlides[scalePositionIndex].scale,
              position: newRenderedSlides[scalePositionIndex].position,
              key: constructor ? -slideIndex : newRenderedSlides[insertIndex].key,
              dataIndex: -1,
              slideIndex,
              opacity: 0,
              zIndex: 0
            };
          }
        }
      }
      var sortedSlideInfo2 = Object.values(slideInfoMap2);
      sortedSlideInfo2.sort(function(slide1, slide2) {
        return slide1.position - slide2.position;
      });
      return {
        renderedSlides: newRenderedSlides,
        centerSlideRelativeIndex: newCenterSlideRelativeIndex,
        slideInfoMap: slideInfoMap2,
        slidePerSide: slidePerSide2,
        newRenderedSlides,
        sortedSlideInfo: sortedSlideInfo2,
        centerPosition: centerPosition2,
        renderedSlidePerSide: renderedSlidePerSide2
      };
    };
    _this.calculateScaleAndOffsets = function(slidePerSide2) {
      var _this$props3 = _this.props, carouselWidth = _this$props3.carouselWidth, slideWidth = _this$props3.slideWidth, customScales = _this$props3.customScales, fadeDistance = _this$props3.fadeDistance;
      var availableSpace = carouselWidth / 2 - slideWidth / 2;
      var scales = [1];
      var scaledSlideWidths = [slideWidth];
      for (var slide = 1; slide <= slidePerSide2; slide++) {
        var scale = customScales ? customScales[slide] : Math.pow(StackedCarousel2.defaultScaleFactor, slide);
        scales.push(scale);
        scaledSlideWidths.push(slideWidth * scale);
      }
      var includedSlideWidths = scaledSlideWidths.slice(1);
      var fillingSpace = availableSpace;
      if (fadeDistance !== void 0) {
        includedSlideWidths = scaledSlideWidths.slice(1, slidePerSide2);
        fillingSpace = availableSpace * (1 - fadeDistance);
      }
      var totalSlideWidth = includedSlideWidths.reduce(function(a, b) {
        return a + b;
      }, 0);
      var offSetPercentage = totalSlideWidth ? fillingSpace / totalSlideWidth : 0;
      var scaledOffsets = [0];
      var offsets = [0];
      for (var _slide = 1; _slide <= slidePerSide2; _slide++) {
        var isCustomFade = fadeDistance !== void 0 && _slide === slidePerSide2;
        var _scale = scales[_slide];
        scaledOffsets[_slide] = isCustomFade ? fadeDistance * availableSpace : slideWidth * _scale * offSetPercentage;
        offsets[_slide] = scaledOffsets[_slide] + slideWidth * ((1 - _scale) / 2);
      }
      return {
        offsets,
        scaledOffsets,
        scales
      };
    };
    _this.getZIndex = function(slideIndex) {
      return _this.renderedSlidePerSide - Math.abs(slideIndex);
    };
    _this.updateHeight = function() {
      var height = _this.props.height;
      if (height)
        return;
      var _this$getSlideDOMInfo = _this.getSlideDOMInfo(0), slideDOM = _this$getSlideDOMInfo.slideDOM;
      var parsedHeight = parseInt(window.getComputedStyle(slideDOM).height);
      if (parsedHeight !== _this.height) {
        _this.height = parsedHeight;
        _this.forceUpdate();
      }
    };
    _this.modDataRange = function(n) {
      var data = _this.props.data;
      var m = data.length;
      return (n % m + m) % m;
    };
    _this.debouncedClearInvisibleSlide = function() {
      var transitionTime = _this.props.transitionTime;
      clearTimeout(_this.clearSlideTimeout);
      _this.clearSlideTimeout = setTimeout(_this.clearUselessSlide, transitionTime !== void 0 ? transitionTime : StackedCarousel2.defaultTransitionTime);
    };
    _this.clearUselessSlide = function() {
      _this.addedSlide = 0;
      var renderedSlides2 = _this.state.renderedSlides;
      var newRenderedSlides = renderedSlides2.filter(function(_ref3) {
        var slideIndex = _ref3.slideIndex, dataIndex = _ref3.dataIndex;
        var absoluteSlideIndex = Math.abs(slideIndex);
        if (absoluteSlideIndex <= _this.slidePerSide || dataIndex === -1) {
          return true;
        }
        return false;
      });
      _this.setState({
        renderedSlides: newRenderedSlides
      });
    };
    _this.safeGetSlideInfo = function(slideIndex) {
      var positionIndex = slideIndex;
      if (positionIndex > _this.slidePerSide) {
        positionIndex = _this.slidePerSide;
      } else if (positionIndex < -_this.slidePerSide) {
        positionIndex = -_this.slidePerSide;
      }
      return _this.slideInfoMap[positionIndex];
    };
    _this.getInsertionInfo = function(steps) {
      var newAddedSlideIndex = steps > 0 ? _this.slidePerSide - steps + 1 : -_this.slidePerSide - steps - 1;
      var targetSlideIndex = steps > 0 ? _this.slidePerSide : -_this.slidePerSide;
      var requireMoreSlide = function requireMoreSlide2(current, target) {
        return steps > 0 ? current <= target : current >= target;
      };
      var updateCount = steps > 0 ? 1 : -1;
      return {
        newAddedSlideIndex,
        targetSlideIndex,
        requireMoreSlide,
        updateCount
      };
    };
    _this.moveCarousel = function(steps, disableSwipeRightState) {
      if (disableSwipeRightState === void 0) {
        disableSwipeRightState = false;
      }
      var renderedSlides2 = _this.state.renderedSlides;
      var onActiveSlideChange2 = _this.props.onActiveSlideChange;
      var newCenterDataIndex = 0;
      var newSlides = renderedSlides2.map(function(oldSlide) {
        var slideIndex = oldSlide.slideIndex, dataIndex = oldSlide.dataIndex;
        if (dataIndex === -1)
          return oldSlide;
        if (slideIndex === 0)
          newCenterDataIndex = _this.modDataRange(dataIndex + steps);
        var newSlideIndex = slideIndex + -steps;
        var slideInfo = _this.safeGetSlideInfo(newSlideIndex);
        return _extends({}, oldSlide, {
          slideIndex: newSlideIndex,
          position: slideInfo.position,
          scale: slideInfo.scale,
          opacity: slideInfo.opacity,
          zIndex: _this.getZIndex(newSlideIndex)
        });
      });
      if (steps !== 0) {
        (function() {
          var maxSlideIndex = steps > 0 ? _this.slidePerSide : -_this.slidePerSide;
          _this.addedSlide += Math.abs(steps);
          var insertionInfo = _this.getInsertionInfo(steps);
          var newAddedSlideIndex = insertionInfo.newAddedSlideIndex;
          var requireMoreSlide = insertionInfo.requireMoreSlide, updateCount = insertionInfo.updateCount, targetSlideIndex = insertionInfo.targetSlideIndex;
          while (requireMoreSlide(newAddedSlideIndex, targetSlideIndex)) {
            var slideAlreadyExist = newSlides.find(function(_ref4) {
              var slideIndex = _ref4.slideIndex;
              return slideIndex === newAddedSlideIndex;
            });
            if (!slideAlreadyExist) {
              var insertPosition = newSlides.findIndex(function(_ref5) {
                var slideIndex = _ref5.slideIndex, dataIndex = _ref5.dataIndex;
                return slideIndex === newAddedSlideIndex - updateCount && dataIndex !== -1;
              });
              var _this$slideInfoMap$ma = _this.slideInfoMap[maxSlideIndex], scale = _this$slideInfoMap$ma.scale, position = _this$slideInfoMap$ma.position;
              var insertDataIndex = _this.modDataRange(newSlides[insertPosition].dataIndex + updateCount);
              _this.keyCount += 1;
              var zIndex = _this.getZIndex(newAddedSlideIndex);
              var insertSlide = {
                scale,
                position,
                opacity: 0,
                zIndex: zIndex - _this.addedSlide,
                slideIndex: newAddedSlideIndex,
                dataIndex: insertDataIndex,
                key: _this.keyCount
              };
              newSlides.splice(steps > 0 ? insertPosition + 1 : insertPosition, 0, insertSlide);
            }
            newAddedSlideIndex += updateCount;
          }
        })();
      }
      if (steps !== 0 && onActiveSlideChange2) {
        onActiveSlideChange2(newCenterDataIndex);
      }
      _this.setState(function() {
        return {
          swipeStarted: false,
          renderedSlides: newSlides,
          swipRight: disableSwipeRightState ? false : steps < 0 ? true : false
        };
      }, function() {
        setTimeout(function() {
          _this.resetSlides();
        }, 0);
      });
    };
    _this.getSlideDOMInfo = function(slideIndex) {
      var slideWidth = _this.props.slideWidth;
      var listRef = _this.listRef.current;
      var slideDOM = listRef.getElementsByClassName("react-stacked-center-carousel-slide-" + slideIndex)[0];
      var slideRect = slideDOM.getBoundingClientRect();
      var _listRef$getBoundingC = listRef.getBoundingClientRect(), carouselLeft = _listRef$getBoundingC.left;
      var scale = slideRect.width / slideWidth;
      var additionalOffset = slideWidth * 0.5 * (1 - scale);
      var slideOffsetLeft = slideRect.left - carouselLeft - additionalOffset;
      var slideCenterOffset = slideOffsetLeft - _this.centerPosition;
      return {
        scale,
        slideDOM,
        slideCenterOffset
      };
    };
    _this.getSlideScaleAndOpacity = function(centerOffset) {
      var targetSlide = _this.sortedSlideInfo.find(function(_ref6) {
        var position2 = _ref6.position;
        return Math.ceil(position2) >= centerOffset;
      }) || _this.sortedSlideInfo[_this.sortedSlideInfo.length - 1];
      var position = targetSlide.position, slideIndex = targetSlide.slideIndex, scale = targetSlide.scale, maxTransformDistance = targetSlide.maxTransformDistance, maxTransformScale = targetSlide.maxTransformScale, maxTransformOpacity = targetSlide.maxTransformOpacity, opacity = targetSlide.opacity;
      var offset = Math.ceil(position) - centerOffset;
      var offsetPercentage = maxTransformDistance.left === 0 ? 0 : offset / maxTransformDistance.left * (slideIndex <= 0 ? -1 : 1);
      return {
        scale: scale + maxTransformScale.left * offsetPercentage,
        opacity: opacity + maxTransformOpacity.left * offsetPercentage
      };
    };
    _this.centerOffset = function(slideIndex) {
      var _this$getSlideDOMInfo2 = _this.getSlideDOMInfo(slideIndex), slideCenterOffset = _this$getSlideDOMInfo2.slideCenterOffset;
      return Math.abs(_this.slideInfoMap[0].position - slideCenterOffset);
    };
    _this.onSwipeStart = function(e) {
      var _this$props4 = _this.props, onActiveSlideChange2 = _this$props4.onActiveSlideChange, disableSwipe = _this$props4.disableSwipe;
      if (disableSwipe)
        return;
      var initalSwipeX = _this.getSwipeX(e);
      var renderedSlides2 = _this.state.renderedSlides;
      clearTimeout(_this.clearSlideTimeout);
      var shiftDirection = 0;
      var centerDataIndex = 0;
      if (_this.centerOffset(-1) < _this.centerOffset(0))
        shiftDirection = 1;
      else if (_this.centerOffset(1) < _this.centerOffset(0))
        shiftDirection = -1;
      var newRenderedSlides = [];
      var swipePositionInfo = [];
      for (var _iterator = _createForOfIteratorHelperLoose(renderedSlides2), _step; !(_step = _iterator()).done; ) {
        var slide = _step.value;
        var slideIndex = slide.slideIndex, dataIndex = slide.dataIndex;
        if (dataIndex === -1) {
          newRenderedSlides.push(slide);
          swipePositionInfo.push({
            slideIndex,
            maxLeft: 0,
            maxRight: 0
          });
          continue;
        }
        var newSlideIndex = slideIndex + shiftDirection;
        if (Math.abs(newSlideIndex) > _this.slidePerSide)
          continue;
        if (newSlideIndex === 0)
          centerDataIndex = dataIndex;
        var _this$getSlideDOMInfo3 = _this.getSlideDOMInfo(slideIndex), slideCenterOffset = _this$getSlideDOMInfo3.slideCenterOffset, scale = _this$getSlideDOMInfo3.scale;
        var _this$getSlideScaleAn = _this.getSlideScaleAndOpacity(slideCenterOffset), opacity = _this$getSlideScaleAn.opacity;
        var _this$safeGetSlideInf = _this.safeGetSlideInfo(newSlideIndex), maxTransformDistance = _this$safeGetSlideInf.maxTransformDistance, position = _this$safeGetSlideInf.position;
        swipePositionInfo.push({
          slideIndex: newSlideIndex,
          maxLeft: slideCenterOffset - position + maxTransformDistance.left,
          maxRight: position + maxTransformDistance.right - slideCenterOffset
        });
        newRenderedSlides.push(_extends({}, slide, {
          scale,
          opacity,
          position: slideCenterOffset,
          slideIndex: newSlideIndex,
          zIndex: _this.getZIndex(newSlideIndex)
        }));
      }
      if (onActiveSlideChange2 && shiftDirection !== 0) {
        onActiveSlideChange2(centerDataIndex);
      }
      _this.setState({
        swipeStarted: true,
        initalSwipeX,
        renderedSlides: newRenderedSlides,
        prevRenderedSlides: [].concat(newRenderedSlides),
        swipePositionInfo
      });
    };
    _this.onSwipe = function(e) {
      var swipeStarted = _this.state.swipeStarted;
      if (!swipeStarted) {
        return;
      }
      var _this$state = _this.state, initalSwipeX = _this$state.initalSwipeX, prevRenderedSlides = _this$state.prevRenderedSlides, swipePositionInfo = _this$state.swipePositionInfo;
      var slideWidth = _this.props.slideWidth;
      var tempShift = false;
      var currentSwipeX = _this.getSwipeX(e);
      var swipeDistance = initalSwipeX - currentSwipeX;
      var delta = Math.abs(swipeDistance);
      var swipeLeft = swipeDistance > 0;
      var transformFactor = 10 / slideWidth * delta;
      var transformPercentage = 1 - Math.pow(1 - (_this.props.swipeSpeed || 0.5), transformFactor);
      var newRenderedSlides = prevRenderedSlides.map(function(slide, index) {
        var position = slide.position, slideIndex = slide.slideIndex, dataIndex = slide.dataIndex;
        if (dataIndex === -1)
          return slide;
        var maxDeltaX = swipePositionInfo[index][swipeLeft ? "maxLeft" : "maxRight"];
        var targetPosition = position + (swipeLeft ? -1 : 1) * maxDeltaX * transformPercentage;
        var _this$getSlideScaleAn2 = _this.getSlideScaleAndOpacity(targetPosition), scale = _this$getSlideScaleAn2.scale, opacity = _this$getSlideScaleAn2.opacity;
        var zIndex = slide.zIndex;
        if (Math.abs(slideIndex) === 1) {
          if (_this.centerOffset(slideIndex) < _this.centerOffset(0)) {
            zIndex = _this.maxZIndex;
            tempShift = true;
          }
        }
        return _extends({}, slide, {
          position: targetPosition,
          scale,
          opacity,
          zIndex
        });
      });
      _this.setState({
        renderedSlides: newRenderedSlides,
        tempShift
      });
    };
    _this.resetSlides = function() {
      var renderedSlides2 = _this.state.renderedSlides;
      var newDefault = renderedSlides2.map(function(slide) {
        var _this$safeGetSlideInf2 = _this.safeGetSlideInfo(slide.slideIndex), opacity = _this$safeGetSlideInf2.opacity, scale = _this$safeGetSlideInf2.scale, position = _this$safeGetSlideInf2.position;
        return _extends({}, slide, {
          zIndex: _this.getZIndex(slide.slideIndex),
          opacity,
          scale,
          position
        });
      });
      _this.setState(function() {
        return {
          renderedSlides: newDefault,
          swipRight: false
        };
      }, _this.debouncedClearInvisibleSlide);
    };
    _this.onSwipeEnd = function() {
      var swipeStarted = _this.state.swipeStarted;
      if (!swipeStarted)
        return;
      var renderedSlides2 = _this.state.renderedSlides;
      var newCenterSlide = renderedSlides2.find(function(_ref7) {
        var zIndex = _ref7.zIndex;
        return zIndex === _this.maxZIndex;
      });
      _this.moveCarousel((newCenterSlide === null || newCenterSlide === void 0 ? void 0 : newCenterSlide.slideIndex) || 0);
      _this.setState({
        tempShift: false
      });
    };
    _this.goNext = function() {
      _this.moveCarousel(1);
    };
    _this.goBack = function() {
      _this.moveCarousel(-1);
    };
    _this.swipeTo = function(steps) {
      _this.moveCarousel(steps);
    };
    var _this$initializePrope = _this.initializeProperties(true), renderedSlides = _this$initializePrope.renderedSlides, slideInfoMap = _this$initializePrope.slideInfoMap, slidePerSide = _this$initializePrope.slidePerSide, sortedSlideInfo = _this$initializePrope.sortedSlideInfo, centerPosition = _this$initializePrope.centerPosition, renderedSlidePerSide = _this$initializePrope.renderedSlidePerSide;
    var onActiveSlideChange = _this.props.onActiveSlideChange;
    _this.slideInfoMap = slideInfoMap;
    _this.sortedSlideInfo = sortedSlideInfo;
    _this.slidePerSide = slidePerSide;
    _this.height = _this.props.height || 0;
    _this.listRef = import_react2.default.createRef();
    _this.clearSlideTimeout = null;
    _this.keyCount = props.data.length;
    _this.addedSlide = 0;
    _this.centerPosition = centerPosition;
    _this.maxZIndex = 100;
    _this.renderedSlidePerSide = renderedSlidePerSide;
    if (onActiveSlideChange) {
      onActiveSlideChange(0);
    }
    _this.state = {
      initalSwipeX: 0,
      swipeStarted: false,
      renderedSlides,
      prevRenderedSlides: [].concat(renderedSlides),
      swipePositionInfo: [],
      swipRight: false,
      tempShift: false
    };
    return _this;
  }
  var _proto = StackedCarousel2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateHeight();
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    clearTimeout(this.clearSlideTimeout);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (!shouldRecaclculate(this.props, prevProps))
      return;
    var _this$initializePrope2 = this.initializeProperties(this.props.maxVisibleSlide !== prevProps.maxVisibleSlide), slideInfoMap = _this$initializePrope2.slideInfoMap, slidePerSide = _this$initializePrope2.slidePerSide, newRenderedSlides = _this$initializePrope2.newRenderedSlides, sortedSlideInfo = _this$initializePrope2.sortedSlideInfo, centerPosition = _this$initializePrope2.centerPosition;
    this.slideInfoMap = slideInfoMap;
    this.sortedSlideInfo = sortedSlideInfo;
    this.slidePerSide = slidePerSide;
    this.centerPosition = centerPosition;
    this.setState(function() {
      return {
        initalSwipeX: 0,
        renderedSlides: newRenderedSlides,
        prevRenderedSlides: [].concat(newRenderedSlides),
        swipRight: false
      };
    }, this.updateHeight);
  };
  _proto.getSwipeX = function getSwipeX(e) {
    if (e.type[0] === "m")
      return e.clientX;
    try {
      var _e$touches$, _e$changedTouches$;
      return ((_e$touches$ = e.touches[0]) === null || _e$touches$ === void 0 ? void 0 : _e$touches$.clientX) || ((_e$changedTouches$ = e.changedTouches[0]) === null || _e$changedTouches$ === void 0 ? void 0 : _e$changedTouches$.clientX);
    } catch (_unused) {
      throw Error("Something went wrong with getting mouse position");
    }
  };
  _proto.render = function render() {
    var _this2 = this;
    var _this$state2 = this.state, swipeStarted = _this$state2.swipeStarted, renderedSlides = _this$state2.renderedSlides, swipRight = _this$state2.swipRight, tempShift = _this$state2.tempShift;
    var _this$props5 = this.props, Component2 = _this$props5.slideComponent, _this$props5$transiti = _this$props5.transitionTime, transitionTime = _this$props5$transiti === void 0 ? StackedCarousel2.defaultTransitionTime : _this$props5$transiti, className = _this$props5.className, data = _this$props5.data, slideWidth = _this$props5.slideWidth, customTransition = _this$props5.customTransition, carouselWidth = _this$props5.carouselWidth, useGrabCursor = _this$props5.useGrabCursor, height = _this$props5.height;
    var cursor = useGrabCursor && (swipeStarted ? "grabbing" : "grab") || "default";
    return import_react2.default.createElement("div", {
      className: "react-stacked-center-carousel " + (className || ""),
      onMouseDown: this.onSwipeStart,
      onMouseUp: this.onSwipeEnd,
      onMouseMove: this.onSwipe,
      onMouseLeave: this.onSwipeEnd,
      onTouchStart: this.onSwipeStart,
      onTouchMove: this.onSwipe,
      onTouchEnd: this.onSwipeEnd,
      ref: this.listRef,
      style: {
        width: carouselWidth,
        height: height || this.height,
        position: "relative",
        overflow: "hidden",
        cursor
      }
    }, renderedSlides.map(function(_ref8) {
      var opacity = _ref8.opacity, slideIndex = _ref8.slideIndex, dataIndex = _ref8.dataIndex, position = _ref8.position, scale = _ref8.scale, key = _ref8.key, zIndex = _ref8.zIndex;
      var ID = dataIndex === -1 ? "hidden-" + key : slideIndex;
      var zDuration = transitionTime * (swipRight ? 0.6 : 1);
      var transition = swipeStarted ? "none" : customTransition || "all " + transitionTime + "ms ease, z-index " + zDuration + "ms ease";
      var isCenterSlide = tempShift ? zIndex === _this2.maxZIndex : slideIndex === 0;
      return import_react2.default.createElement("div", {
        key,
        className: "react-stacked-center-carousel-slide-" + ID,
        draggable: false,
        style: {
          position: "absolute",
          display: "flex",
          left: "calc(50% - " + slideWidth / 2 + "px)",
          transform: "translateX(" + position + "px) scale(" + scale + ")",
          width: slideWidth,
          transition,
          opacity,
          zIndex
        }
      }, dataIndex !== -1 && import_react2.default.createElement(Component2, {
        dataIndex,
        data,
        slideIndex,
        isCenterSlide,
        swipeTo: _this2.swipeTo
      }));
    }));
  };
  return StackedCarousel2;
}(import_react2.default.PureComponent);
StackedCarousel.defaultScaleFactor = 0.85;
StackedCarousel.defaultTransitionTime = 450;
function shouldRecaclculate(prop1, prop2) {
  var _prop1$customScales, _prop2$customScales;
  if (prop1.slideWidth !== prop2.slideWidth || prop1.carouselWidth !== prop2.carouselWidth || prop1.maxVisibleSlide !== prop2.maxVisibleSlide || prop1.currentVisibleSlide !== prop2.currentVisibleSlide || prop1.fadeDistance !== prop2.fadeDistance || ((_prop1$customScales = prop1.customScales) === null || _prop1$customScales === void 0 ? void 0 : _prop1$customScales.join("")) !== ((_prop2$customScales = prop2.customScales) === null || _prop2$customScales === void 0 ? void 0 : _prop2$customScales.join("")))
    return true;
  return false;
}
function ResponsiveContainer(props) {
  var render = props.render, carouselRef = props.carouselRef;
  var _useResizeDetector = useResizeDetector(), width = _useResizeDetector.width, ref = _useResizeDetector.ref;
  return import_react2.default.createElement("div", {
    ref,
    className: "stacked-carousel-responsive-container",
    style: {
      width: "100%"
    }
  }, width && render(width, carouselRef));
}
export {
  ResponsiveContainer,
  StackedCarousel
};
//# sourceMappingURL=react-stacked-center-carousel.js.map
